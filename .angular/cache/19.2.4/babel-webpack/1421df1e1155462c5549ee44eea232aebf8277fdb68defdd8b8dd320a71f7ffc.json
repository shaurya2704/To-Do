{"ast":null,"code":"import _asyncToGenerator from \"/Users/shaurya.singh/Desktop/To-Do List/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { supportsLocalStorage } from './helpers';\n/**\n * @experimental\n */\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport class LockAcquireTimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.isAcquireTimeout = true;\n  }\n}\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport function navigatorLock(_x, _x2, _x3) {\n  return _navigatorLock.apply(this, arguments);\n}\nfunction _navigatorLock() {\n  _navigatorLock = _asyncToGenerator(function* (name, acquireTimeout, fn) {\n    if (internals.debug) {\n      console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n      setTimeout(() => {\n        abortController.abort();\n        if (internals.debug) {\n          console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n        }\n      }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return yield Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n      mode: 'exclusive',\n      ifAvailable: true\n    } : {\n      mode: 'exclusive',\n      signal: abortController.signal\n    }, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (lock) {\n        if (lock) {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n          }\n          try {\n            return yield fn();\n          } finally {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n            }\n          }\n        } else {\n          if (acquireTimeout === 0) {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n            }\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n          } else {\n            if (internals.debug) {\n              try {\n                const result = yield globalThis.navigator.locks.query();\n                console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n              } catch (e) {\n                console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n              }\n            }\n            // Browser is not following the Navigator LockManager spec, it\n            // returned a null lock when we didn't use ifAvailable. So we can\n            // pretend the lock is acquired in the name of backward compatibility\n            // and user experience and just run the function.\n            console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n            return yield fn();\n          }\n        }\n      });\n      return function (_x7) {\n        return _ref.apply(this, arguments);\n      };\n    }()));\n  });\n  return _navigatorLock.apply(this, arguments);\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport function processLock(_x4, _x5, _x6) {\n  return _processLock.apply(this, arguments);\n}\nfunction _processLock() {\n  _processLock = _asyncToGenerator(function* (name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([previousOperation.catch(() => {\n      // ignore error of previous operation that we're waiting to finish\n      return null;\n    }), acquireTimeout >= 0 ? new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n      }, acquireTimeout);\n    }) : null].filter(x => x)).catch(e => {\n      if (e && e.isAcquireTimeout) {\n        throw e;\n      }\n      return null;\n    }).then(/*#__PURE__*/_asyncToGenerator(function* () {\n      // previous operations finished and we didn't get a race on the acquire\n      // timeout, so the current operation can finally start\n      return yield fn();\n    }));\n    PROCESS_LOCKS[name] = currentOperation.catch(/*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (e) {\n        if (e && e.isAcquireTimeout) {\n          // if the current operation timed out, it doesn't mean that the previous\n          // operation finished, so we need contnue waiting for it to finish\n          yield previousOperation;\n          return null;\n        }\n        throw e;\n      });\n      return function (_x8) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return yield currentOperation;\n  });\n  return _processLock.apply(this, arguments);\n}","map":{"version":3,"names":["supportsLocalStorage","internals","debug","globalThis","localStorage","getItem","LockAcquireTimeoutError","Error","constructor","message","isAcquireTimeout","NavigatorLockAcquireTimeoutError","ProcessLockAcquireTimeoutError","navigatorLock","_x","_x2","_x3","_navigatorLock","apply","arguments","_asyncToGenerator","name","acquireTimeout","fn","console","log","abortController","AbortController","setTimeout","abort","Promise","resolve","then","navigator","locks","request","mode","ifAvailable","signal","_ref","lock","result","query","JSON","stringify","e","warn","_x7","PROCESS_LOCKS","processLock","_x4","_x5","_x6","_processLock","_a","previousOperation","currentOperation","race","catch","_","reject","filter","x","_ref3","_x8"],"sources":["/Users/shaurya.singh/Desktop/To-Do List/node_modules/@supabase/auth-js/dist/module/lib/locks.js"],"sourcesContent":["import { supportsLocalStorage } from './helpers';\n/**\n * @experimental\n */\nexport const internals = {\n    /**\n     * @experimental\n     */\n    debug: !!(globalThis &&\n        supportsLocalStorage() &&\n        globalThis.localStorage &&\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport class LockAcquireTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n        }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n        }, async (lock) => {\n        if (lock) {\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n            }\n            try {\n                return await fn();\n            }\n            finally {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                }\n            }\n        }\n        else {\n            if (acquireTimeout === 0) {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                }\n                throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n            }\n            else {\n                if (internals.debug) {\n                    try {\n                        const result = await globalThis.navigator.locks.query();\n                        console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                    }\n                    catch (e) {\n                        console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n                    }\n                }\n                // Browser is not following the Navigator LockManager spec, it\n                // returned a null lock when we didn't use ifAvailable. So we can\n                // pretend the lock is acquired in the name of backward compatibility\n                // and user experience and just run the function.\n                console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                return await fn();\n            }\n        }\n    }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(() => {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0\n            ? new Promise((_, reject) => {\n                setTimeout(() => {\n                    reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n                }, acquireTimeout);\n            })\n            : null,\n    ].filter((x) => x))\n        .catch((e) => {\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    })\n        .then(async () => {\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e) => {\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}