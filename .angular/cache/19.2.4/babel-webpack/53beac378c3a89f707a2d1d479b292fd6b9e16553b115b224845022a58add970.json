{"ast":null,"code":"/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n  const charMap = new Array(128);\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1;\n  }\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n  }\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n  }\n  return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(byte, state, emit) {\n  if (byte !== null) {\n    state.queue = state.queue << 8 | byte;\n    state.queuedBits += 8;\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << 6 - state.queuedBits;\n    state.queuedBits = 6;\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(charCode, state, emit) {\n  const bits = FROM_BASE64URL[charCode];\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = state.queue << 6 | bits;\n    state.queuedBits += 6;\n    while (state.queuedBits >= 8) {\n      emit(state.queue >> state.queuedBits - 8 & 0xff);\n      state.queuedBits -= 8;\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return;\n  } else {\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n  }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str) {\n  const base64 = [];\n  const emitter = char => {\n    base64.push(char);\n  };\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  stringToUTF8(str, byte => {\n    byteToBase64URL(byte, state, emitter);\n  });\n  byteToBase64URL(null, state, emitter);\n  return base64.join('');\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str) {\n  const conv = [];\n  const utf8Emit = codepoint => {\n    conv.push(String.fromCodePoint(codepoint));\n  };\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0\n  };\n  const b64State = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const byteEmit = byte => {\n    stringFromUTF8(byte, utf8State, utf8Emit);\n  };\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n  }\n  return conv.join('');\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint, emit) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint);\n    return;\n  } else if (codepoint <= 0x7ff) {\n    emit(0xc0 | codepoint >> 6);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0xffff) {\n    emit(0xe0 | codepoint >> 12);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0x10ffff) {\n    emit(0xf0 | codepoint >> 18);\n    emit(0x80 | codepoint >> 12 & 0x3f);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  }\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str, emit) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i);\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n      const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n      i += 1;\n    }\n    codepointToUTF8(codepoint, emit);\n  }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(byte, state, emit) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte);\n      return;\n    }\n    // count the number of 1 leading bits until you reach 0\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if ((byte >> 7 - leadingBit & 1) === 0) {\n        state.utf8seq = leadingBit;\n        break;\n      }\n    }\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31;\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15;\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7;\n    } else {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n    state.utf8seq -= 1;\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n    state.codepoint = state.codepoint << 6 | byte & 63;\n    state.utf8seq -= 1;\n    if (state.utf8seq === 0) {\n      emit(state.codepoint);\n    }\n  }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\nexport function base64UrlToUint8Array(str) {\n  const result = [];\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const onByte = byte => {\n    result.push(byte);\n  };\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), state, onByte);\n  }\n  return new Uint8Array(result);\n}\nexport function stringToUint8Array(str) {\n  const result = [];\n  stringToUTF8(str, byte => result.push(byte));\n  return new Uint8Array(result);\n}","map":{"version":3,"names":["TO_BASE64URL","split","IGNORE_BASE64URL","FROM_BASE64URL","charMap","Array","i","length","charCodeAt","byteToBase64URL","byte","state","emit","queue","queuedBits","pos","byteFromBase64URL","charCode","bits","Error","String","fromCharCode","stringToBase64URL","str","base64","emitter","char","push","stringToUTF8","join","stringFromBase64URL","conv","utf8Emit","codepoint","fromCodePoint","utf8State","utf8seq","b64State","byteEmit","stringFromUTF8","codepointToUTF8","toString","highSurrogate","lowSurrogate","leadingBit","base64UrlToUint8Array","result","onByte","Uint8Array","stringToUint8Array"],"sources":["/Users/shaurya.singh/Desktop/To-Do List/node_modules/@supabase/auth-js/dist/module/lib/base64url.js"],"sourcesContent":["/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n    const charMap = new Array(128);\n    for (let i = 0; i < charMap.length; i += 1) {\n        charMap[i] = -1;\n    }\n    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = (state.queue << 8) | byte;\n        state.queuedBits += 8;\n        while (state.queuedBits >= 6) {\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n    else if (state.queuedBits > 0) {\n        state.queue = state.queue << (6 - state.queuedBits);\n        state.queuedBits = 6;\n        while (state.queuedBits >= 6) {\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = (state.queue << 6) | bits;\n        state.queuedBits += 6;\n        while (state.queuedBits >= 8) {\n            emit((state.queue >> (state.queuedBits - 8)) & 0xff);\n            state.queuedBits -= 8;\n        }\n    }\n    else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    }\n    else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char) => {\n        base64.push(char);\n    };\n    const state = { queue: 0, queuedBits: 0 };\n    stringToUTF8(str, (byte) => {\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join('');\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint) => {\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0,\n    };\n    const b64State = { queue: 0, queuedBits: 0 };\n    const byteEmit = (byte) => {\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join('');\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    }\n    else if (codepoint <= 0x7ff) {\n        emit(0xc0 | (codepoint >> 6));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    else if (codepoint <= 0xffff) {\n        emit(0xe0 | (codepoint >> 12));\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | (codepoint >> 18));\n        emit(0x80 | ((codepoint >> 12) & 0x3f));\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str, emit) {\n    for (let i = 0; i < str.length; i += 1) {\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff;\n            const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n            if (((byte >> (7 - leadingBit)) & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        }\n        else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        }\n        else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        }\n        else {\n            throw new Error('Invalid UTF-8 sequence');\n        }\n        state.utf8seq -= 1;\n    }\n    else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error('Invalid UTF-8 sequence');\n        }\n        state.codepoint = (state.codepoint << 6) | (byte & 63);\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\nexport function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = { queue: 0, queuedBits: 0 };\n    const onByte = (byte) => {\n        result.push(byte);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nexport function stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte) => result.push(byte));\n    return new Uint8Array(result);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}